// edit_generated_tool (moved into mcp_tooling)
import { access, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { spawn } from 'node:child_process';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import type { ToolArguments } from '../../tools/types.js';
import { isPlainObject, isRecordOfStrings } from '../../utils/typeGuards.js';

function isValidBaseName(name: string): boolean {
  return /^[a-z0-9_]+$/.test(name);
}

async function exists(p: string): Promise<boolean> {
  try {
    await access(p);
    return true;
  } catch {
    return false;
  }
}

function ensureInsideBase(baseDir: string, target: string): boolean {
  const base = path.resolve(baseDir);
  const resolved = path.resolve(target);
  return resolved === base || resolved.startsWith(base + path.sep);
}

interface PackageJson {
  dependencies?: Record<string, string>;
  [key: string]: unknown;
}

function indentLines(s: string, spaces = 4): string {
  const pad = ' '.repeat(spaces);
  return s.split('\n').map(line => (line ? pad + line : line)).join('\n');
}

function detectDangerousPatterns(src: string): { blocking: string[]; warnings: string[] } {
  const blocking: string[] = [];
  const warnings: string[] = [];
  const checks: Array<{ re: RegExp; label: string; warn?: boolean }> = [
    { re: /\bchild_process\b/, label: 'child_process' },
    { re: /\bspawn\s*\(/, label: 'spawn()' },
    { re: /\bexec\s*\(/, label: 'exec()' },
    { re: /\bexecFile\s*\(/, label: 'execFile()' },
    { re: /\bfork\s*\(/, label: 'fork()' },
    { re: /\bwriteFile\s*\(/, label: 'fs.writeFile' },
    { re: /\bappendFile\s*\(/, label: 'fs.appendFile' },
    { re: /\brm\s*\(/, label: 'fs.rm' },
    { re: /\brmdir\s*\(/, label: 'fs.rmdir' },
    { re: /\bunlink\s*\(/, label: 'fs.unlink' },
    { re: /\brename\s*\(/, label: 'fs.rename' },
    { re: /\bchmod\s*\(/, label: 'fs.chmod' },
    { re: /\bchown\s*\(/, label: 'fs.chown' },
    { re: /\bcp\s*\(/, label: 'fs.cp' },
    { re: /\beval\s*\(/, label: 'eval()' },
    { re: /new\s+Function\b/, label: 'new Function' },
    { re: /\bvm\./, label: 'vm module' },
    { re: /\.\.\//, label: '../ path traversal' },
    { re: /\bprocess\.env\b/, label: 'process.env', warn: true },
    { re: /\b(?:from\s+['"][\w@/-]+['"]|require\(\s*['"][\w@/-]+['"]\s*\)|import\(\s*['"][\w@/-]+['"]\s*\))/, label: 'dynamic import', warn: true },
  ];
  for (const c of checks) {
    if (c.re.test(src)) {
      if (c.warn) warnings.push(c.label);
      else blocking.push(c.label);
    }
  }
  return { blocking, warnings };
}

function textResponse(message: string, isError = true): CallToolResult {
  return {
    content: [{ type: 'text', text: message }],
    isError,
  };
}

async function updateDependencies(projectRoot: string, deps: Record<string, string> | undefined) {
  if (!deps || Object.keys(deps).length === 0) return { updated: false, added: [] as string[] };
  const pkgPath = path.join(projectRoot, 'package.json');
  const raw = await readFile(pkgPath, 'utf8');
  const pkg: PackageJson = JSON.parse(raw);
  pkg.dependencies ||= {};
  const added: string[] = [];
  for (const [name, version] of Object.entries(deps)) {
    if (!pkg.dependencies[name]) {
      pkg.dependencies[name] = version;
      added.push(`${name}@${version}`);
    }
  }
  if (added.length) {
    await writeFile(pkgPath, JSON.stringify(pkg, null, 2) + '\n', 'utf8');
    return { updated: true, added };
  }
  return { updated: false, added: [] };
}

async function runBunInstall(projectRoot: string, timeoutMs: number) {
  return await new Promise<{ ok: boolean; code: number | null; signal?: string; reason?: string }>((resolve) => {
    const child = spawn('bun', ['install'], { cwd: projectRoot, stdio: 'inherit', env: process.env });
    const timer = setTimeout(() => {
      try { child.kill('SIGKILL'); } catch { /* ignore */ }
      resolve({ ok: false, code: null, reason: `Timed out after ${timeoutMs}ms` });
    }, timeoutMs);
    child.on('exit', (code, signal) => {
      clearTimeout(timer);
      resolve({ ok: code === 0, code, signal: signal ?? undefined });
    });
    child.on('error', () => {
      clearTimeout(timer);
      resolve({ ok: false, code: null, reason: 'Failed to start bun install' });
    });
  });
}

const GENERATED_HEADER_MARKERS = [
  '[generated-tool] This tool was generated by create_mcp_tool',
  '[generated-tool] This tool was generated by generated_create_mcp_tool',
];

const tool = {
  name: 'edit_generated_tool',
  description: 'Edit a generated MCP plugin. Only tools with generated_ prefix and generator header are allowed.',
  inputSchema: {
    type: 'object',
    additionalProperties: false,
    properties: {
      tool_name: { type: 'string', pattern: '^generated_[a-z0-9_]+$' },
      base_name: { type: 'string', pattern: '^[a-z0-9_]+$' },
      description: { type: 'string' },
      input_schema: { type: 'object' },
      handler_code: { type: 'string' },
      required_packages: { type: 'object', additionalProperties: { type: 'string' } },
      allow_unsafe: { type: 'boolean', default: false },
      install_dependencies: { type: 'boolean', default: false }
    }
  },
  handler: async (args: ToolArguments, signal: AbortSignal) => {
    if (signal.aborted) throw new Error('Aborted');

    const toolNameArg = typeof args.tool_name === 'string' ? args.tool_name : undefined;
    const baseNameArg = typeof args.base_name === 'string' ? args.base_name : undefined;
    const descArg = typeof args.description === 'string' ? args.description : undefined;
    const schemaCandidate = args.input_schema;
    const schemaArg = isPlainObject(schemaCandidate) ? schemaCandidate : undefined;
    const handlerCodeArg = typeof args.handler_code === 'string' ? args.handler_code : undefined;
    const reqPkgsArg = isRecordOfStrings(args.required_packages) ? args.required_packages : undefined;
    const allowUnsafe = args.allow_unsafe === true;
    const installDeps = args.install_dependencies === true;

    const finalName = toolNameArg ?? (baseNameArg ? `generated_${baseNameArg}` : undefined);
    if (!finalName || !finalName.startsWith('generated_') || (baseNameArg && !isValidBaseName(baseNameArg))) {
      return textResponse('Provide tool_name (generated_*) or valid base_name.');
    }

    const projectRoot = process.cwd();
    const pluginsRoot = path.join(projectRoot, 'src', 'plugins');
    const pluginDir = path.join(pluginsRoot, finalName);
    const tsPath = path.join(pluginDir, 'index.ts');
    const jsPath = path.join(pluginDir, 'index.js');

    if (!ensureInsideBase(pluginsRoot, pluginDir)) {
      return textResponse('Refusing to operate outside src/plugins.');
    }

    let filePath = '';
    if (await exists(tsPath)) filePath = tsPath;
    else if (await exists(jsPath)) filePath = jsPath;
    else return textResponse('index.ts/js not found for tool');

    const source = await readFile(filePath, 'utf8');
    const isGenerated = GENERATED_HEADER_MARKERS.some(m => source.includes(m));
    if (!isGenerated) {
      return textResponse('Refusing to edit: not recognized as a generated tool.');
    }

    if (handlerCodeArg) {
      const issues = detectDangerousPatterns(handlerCodeArg);
      if ((issues.blocking.length > 0 || issues.warnings.length > 0) && !allowUnsafe) {
        const msg = [
          issues.blocking.length ? `Blocking: ${issues.blocking.join(', ')}` : '',
          issues.warnings.length ? `Warnings: ${issues.warnings.join(', ')}` : ''
        ].filter(Boolean).join(' | ');
        return textResponse(`Unsafe constructs detected. Aborting. ${msg}`);
      }
    }

    const descMatch = source.match(/\bdescription:\s*([`'"])(.*?)\1/s);
    const currentDesc = descMatch ? descMatch[2] : '';

    function extractObjectAfter(label: string): string | null {
      const idx = source.indexOf(label);
      if (idx < 0) return null;
      const startBrace = source.indexOf('{', idx);
      if (startBrace < 0) return null;
      let depth = 0;
      for (let i = startBrace; i < source.length; i++) {
        const ch = source[i];
        if (ch === '{') depth++;
        else if (ch === '}') {
          depth--;
          if (depth === 0) {
            return source.slice(startBrace, i + 1);
          }
        }
      }
      return null;
    }

    const currentSchemaStr = extractObjectAfter('inputSchema:') ?? '{}';

    function extractHandlerBody(): string | null {
      const hIdx = source.indexOf('handler:');
      if (hIdx < 0) return null;
      const arrowIdx = source.indexOf('=>', hIdx);
      if (arrowIdx < 0) return null;
      const bodyStart = source.indexOf('{', arrowIdx);
      if (bodyStart < 0) return null;
      let depth = 0;
      for (let i = bodyStart; i < source.length; i++) {
        const ch = source[i];
        if (ch === '{') depth++;
        else if (ch === '}') {
          depth--;
          if (depth === 0) {
            return source.slice(bodyStart + 1, i);
          }
        }
      }
      return null;
    }

    const currentHandlerBody = extractHandlerBody() ?? "return [{ type: 'text', text: 'ok' }];";

    function extractRequiredPackages(): string | null {
      const key = 'export const requiredPackages =';
      const idx = source.indexOf(key);
      if (idx < 0) return null;
      const start = source.indexOf('{', idx);
      if (start < 0) return null;
      let depth = 0;
      for (let i = start; i < source.length; i++) {
        const ch = source[i];
        if (ch === '{') depth++;
        else if (ch === '}') {
          depth--;
          if (depth === 0) return source.slice(start, i + 1);
        }
      }
      return null;
    }

    const currentReqPkgsStr = extractRequiredPackages();

    const newDesc = descArg ?? currentDesc;
    const newSchemaStr = schemaArg ? JSON.stringify(schemaArg, null, 2) : currentSchemaStr;
    const newHandlerBody = handlerCodeArg ?? currentHandlerBody;
    const newReqPkgsStr = reqPkgsArg ? JSON.stringify(reqPkgsArg, null, 2) : currentReqPkgsStr;

    const headerLine = source.split('\n', 1)[0] ?? '';

    const rebuilt = [
      headerLine.includes('[generated-tool]') ? headerLine : "// [generated-tool] This tool was generated by create_mcp_tool",
      '',
      newReqPkgsStr ? `export const requiredPackages = ${newReqPkgsStr};` : '',
      'const tool = {',
      `  name: ${JSON.stringify(finalName)},`,
      `  description: ${JSON.stringify(newDesc)},`,
      `  inputSchema: ${newSchemaStr},`,
      '  handler: async (args: Record<string, unknown>, signal: AbortSignal) => {',
      '    if (signal.aborted) throw new Error("Aborted");',
      indentLines(newHandlerBody, 4),
      '  },',
      '};',
      '',
      'export default tool;',
      ''
    ].filter(Boolean).join('\n');

    await writeFile(filePath, rebuilt, 'utf8');

    let depsUpdated = false;
    let depsAdded: string[] = [];
    if (reqPkgsArg && Object.keys(reqPkgsArg).length) {
      const res = await updateDependencies(projectRoot, reqPkgsArg);
      depsUpdated = res.updated;
      depsAdded = res.added;
    }

    if (installDeps) {
      const result = await runBunInstall(projectRoot, 120000);
      if (!result.ok) {
        // continue
      }
    }

    try {
      const { toolRegistry } = await import('../../tools/registry.js');
      const refresh = toolRegistry.getTool?.('refresh_plugins');
      if (refresh?.handler) {
        const refreshArgs: ToolArguments = { plugin: finalName };
        await refresh.handler(refreshArgs, signal);
      }
    } catch { /* ignore */ }

    const lines = [
      `Edited generated tool: ${finalName}`,
      descArg ? 'Updated description' : '',
      schemaArg ? 'Updated input_schema' : '',
      handlerCodeArg ? 'Updated handler_code' : '',
      reqPkgsArg ? (depsUpdated ? `Updated dependencies: ${depsAdded.join(', ')}` : 'Dependencies unchanged') : ''
    ].filter(Boolean).join(' | ');

    return textResponse(lines || `Edited ${finalName}`, false);
  }
};

export default tool;
// remove_generated_tool (moved into mcp_tooling)
import { rm, access, readFile } from 'node:fs/promises';
import path from 'node:path';
import type { ToolArguments } from '../../tools/types.js';
import { EMPTY_TOOL_ARGS } from '../../tools/types.js';

function isValidBaseName(name: string): boolean {
  return /^[a-z0-9_]+$/.test(name);
}

function ensureInsideBase(baseDir: string, target: string): boolean {
  const base = path.resolve(baseDir);
  const resolved = path.resolve(target);
  return resolved === base || resolved.startsWith(base + path.sep);
}

async function fileExists(p: string): Promise<boolean> {
  try {
    await access(p);
    return true;
  } catch {
    return false;
  }
}

const GENERATED_HEADER_MARKERS = [
  '[generated-tool] This tool was generated by create_mcp_tool',
  '[generated-tool] This tool was generated by generated_create_mcp_tool',
];

const tool = {
  name: 'remove_generated_tool',
  description: 'Remove a generated MCP plugin (only tools with generated_ prefix and generator header).',
  inputSchema: {
    type: 'object',
    additionalProperties: false,
    properties: {
      tool_name: {
        type: 'string',
        description: 'Full tool name starting with generated_',
        pattern: '^generated_[a-z0-9_]+$'
      },
      base_name: {
        type: 'string',
        description: 'Base name without prefix (snake_case)',
        pattern: '^[a-z0-9_]+$'
      }
    }
  },
  handler: async (args: ToolArguments, signal: AbortSignal) => {
    if (signal.aborted) throw new Error('Aborted');

    const toolNameArg = typeof args.tool_name === 'string' ? args.tool_name : undefined;
    const baseNameArg = typeof args.base_name === 'string' ? args.base_name : undefined;

    if (!toolNameArg && !baseNameArg) {
      return { content: [{ type: 'text', text: 'Provide tool_name (generated_*) or base_name.' }], isError: true };
    }

    let finalName: string;
    if (toolNameArg) {
      if (!toolNameArg.startsWith('generated_')) {
        return { content: [{ type: 'text', text: 'tool_name must start with generated_.' }], isError: true };
      }
      finalName = toolNameArg;
    } else {
      if (!isValidBaseName(baseNameArg!)) {
        return { content: [{ type: 'text', text: 'base_name must match ^[a-z0-9_]+$.' }], isError: true };
      }
      finalName = `generated_${baseNameArg}`;
    }

    const projectRoot = process.cwd();
    const pluginsRoot = path.join(projectRoot, 'src', 'plugins');
    const pluginDir = path.join(pluginsRoot, finalName);

    if (!ensureInsideBase(pluginsRoot, pluginDir)) {
      return { content: [{ type: 'text', text: 'Refusing to operate outside src/plugins.' }], isError: true };
    }

    if (!(await fileExists(pluginDir))) {
      return { content: [{ type: 'text', text: `Plugin directory not found: ${pluginDir}` }], isError: true };
    }

    const tsPath = path.join(pluginDir, 'index.ts');
    const jsPath = path.join(pluginDir, 'index.js');

    let headerOk = false;
    if (await fileExists(tsPath)) {
      const src = await readFile(tsPath, 'utf8');
      headerOk = GENERATED_HEADER_MARKERS.some(m => src.includes(m));
    } else if (await fileExists(jsPath)) {
      const src = await readFile(jsPath, 'utf8');
      headerOk = GENERATED_HEADER_MARKERS.some(m => src.includes(m));
    }

    if (!headerOk || !finalName.startsWith('generated_')) {
      return { content: [{ type: 'text', text: 'Refusing to remove: not recognized as a generated tool.' }], isError: true };
    }

    await rm(pluginDir, { recursive: true, force: false });

    try {
      const { toolRegistry } = await import('../../tools/registry.js');
      const refresh = toolRegistry.getTool?.('refresh_plugins');
      if (refresh?.handler) {
        await refresh.handler(EMPTY_TOOL_ARGS, signal);
      }
    } catch {
      // ignore
    }

    return { content: [{ type: 'text', text: `Removed generated tool: ${finalName}` }] };
  }
};

export default tool;
